+++
title = 'Redis核心数据结构及应用场景'
date = 2024-05-30T08:00:45Z
draft = false
+++

## 五种核心数据结构及其应用场景

### String

最基本的类型，一个 key 对应一个 value，value 其实不仅可以是 String，也可以是数字。常规 key-value 缓存应用。

**应用场景**

1. 缓存：
   如果我们有一个用户信息，用户 ID 为 123，用户信息为"John"，我们可以这样存储：

   ```
   SET user:123 "John"
   ```

   当我们需要获取这个用户的信息时，我们可以这样获取：

   ```
   GET user:123
   ```

1. 计数器：

   如果我们需要对一个网页的访问次数进行计数，我们可以这样操作：

   ```
   INCR page_view:1
   ```

   每当有新的访问时，我们就执行上面的命令，这样就可以实时统计网页的访问次数。

1. 分布式锁：

   如果我们需要对一个资源进行加锁，我们可以这样操作：

   ```
   SET lock:resource_name "lock_value" NX EX 30
   ```

   这个命令会尝试设置一个键，如果这个键不存在，那么设置成功，我们就获取到了锁，如果这个键已经存在，那么设置失败，我们就没有获取到锁。EX 参数表示这个键的过期时间，这样可以防止死锁。

1. 会话缓存：

   如果我们需要存储一个用户的会话信息，我们可以这样操作：

   ```
   SET session:123 "session_info"
   ```

   当我们需要获取这个用户的会话信息时，我们可以这样获取：

   ```
   GET session:123
   ```

1. 页面缓存：

   如果我们需要缓存一个网页的内容，我们可以这样操作：

   ```
   SET page:1 "page_content"
   ```

   当我们需要获取这个网页的内容时，我们可以这样获取：

   ```
   GET page:1
   ```

1. 分布式系统全局序列号

   redis 批量生成序列号提升性能

   ```
   INCRBY  orderId  1000

   ```

### Hash

用于存储对象，即多个字段及字段值，通过 key 和字段名（field）来唯一确定一个值。适合用于存储对象。

**应用场景**

1. 存储对象：哈希表是存储对象的理想选择。例如，如果你有一个用户对象，你可以使用用户的 ID 作为键，用户的其他信息（如姓名、电子邮件等）作为值。

   示例：

   ```
   HSET user:1000 name "John Doe"
   HSET user:1000 email "john.doe@example.com"
   ```

2. 缓存：哈希表可以用作缓存，以加快数据检索速度。例如，你可以将数据库查询的结果存储在哈希表中，当再次需要这些数据时，可以直接从哈希表中获取，而不需要再次查询数据库。

   示例：

   ```
   HSET cache:products product:1000 "{...product data...}"
   ```

3. 计数器：哈希表也可以用作计数器。例如，你可以使用哈希表来跟踪网站的页面访问次数。

   示例：

   ```
   HINCRBY pageviews /index.html 1
   ```

4. 数据去重：哈希表可以用来检查数据是否已经存在，从而避免数据的重复。例如，你可以使用哈希表来检查一个电子邮件地址是否已经被注册。

   示例：

   ```
   HSETNX emails john.doe@example.com 1
   ```

5. 哈希表在电商购物车的应用中非常常见，它可以用来存储用户的购物车信息。

   1. 存储购物车信息：哈希表可以用来存储用户的购物车信息。例如，你可以使用用户的 ID 作为键，购物车中的商品 ID 和数量作为值。

      示例：

      ```
      HSET cart:1000 product:2001 3
      HSET cart:1000 product:2002 2
      ```

      这表示用户 ID 为 1000 的购物车中，商品 ID 为 2001 的商品数量为 3，商品 ID 为 2002 的商品数量为 2。

   2. 更新购物车信息：当用户在购物车中增加或减少商品数量时，可以使用哈希表的 HINCRBY 命令来更新购物车信息。

      示例：

      ```
      HINCRBY cart:1000 product:2001 1
      ```

      这表示将用户 ID 为 1000 的购物车中，商品 ID 为 2001 的商品数量增加 1。

   3. 获取购物车信息：当用户查看购物车时，可以使用 HGETALL 命令来获取购物车中的所有商品信息。

      示例：

      ```
      HGETALL cart:1000
      ```

      这将返回用户 ID 为 1000 的购物车中的所有商品信息。

   4. 删除购物车信息：当用户从购物车中删除商品时，可以使用 HDEL 命令来删除购物车中的商品信息。

      示例：

      ```
      HDEL cart:1000 product:2001
      ```

      这将删除用户 ID 为 1000 的购物车中，商品 ID 为 2001 的商品信息。

#### 优缺点

**优点：**

1. 同类数据归类整合储存：哈希表可以将同类数据整合在一起存储，这使得数据管理更加方便。

2. 较小的内存和 CPU 消耗：相比于字符串操作，哈希表的操作对内存和 CPU 的消耗更小，这使得哈希表在处理大量数据时更加高效。

3. 更节省空间：相比于字符串存储，哈希表的存储更加节省空间。这是因为哈希表可以将数据压缩存储，而不需要为每个数据都分配一个独立的内存空间。

**缺点：**

1. 过期功能的限制：在哈希表中，过期功能只能应用在键上，不能应用在字段上。这意味着你不能单独设置一个字段的过期时间，只能设置整个哈希表的过期时间。

2. 在 Redis 集群架构下的限制：在 Redis 集群架构下，哈希表不适合大规模使用。这是因为在集群架构下，哈希表的数据分布可能会导致数据不均衡，从而影响集群的性能。

### List

Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。

**应用场景**

1. 时间线或新闻 feed：你可以使用`LPUSH`命令将新的动态添加到时间线 List 的头部。

   示例：`LPUSH user:1:timeline "User 1's new status"`

2. 最近使用的内容：你可以使用`LPUSH`命令将用户最近查看的商品添加到 List 的头部，然后使用`LTRIM`命令保持 List 的长度，只保留最近查看的一定数量的商品。

   示例：
   `LPUSH user:1:recently_viewed "Product 1"`
   `LTRIM user:1:recently_viewed 0 9`

3. 实现栈或队列：你可以使用`LPUSH`命令将新的任务添加到待处理任务 List 的头部，然后使用`RPOP`命令从 List 的尾部取出一个任务进行处理。

```
Stack(栈) = LPUSH + LPOP
Queue(队列）= LPUSH + RPOP
Blocking MQ(阻塞队列）= LPUSH + BRPOP
```

4. 浏览器历史：你可以使用`LPUSH`命令将新访问的网页添加到浏览历史 List 的头部。

   示例：`LPUSH user:1:history "www.example.com"`

以上就是一些具体的 Redis 命令示例，希望对你有所帮助。

### Set

集合是字符串的无序集合。和列表一样，你可以添加、删除、查看集合中的元素。

社交网络应用：

1. 关注的人：可以使用 Set 来存储用户关注的人。例如，当用户 A 关注了用户 B 和用户 C 时，你可以使用`SADD`命令将用户 B 和用户 C 添加到用户 A 的关注 Set 中。

   示例：`SADD userA:following "userB" "userC"`

2. 共同关注：如果你想要找出两个用户共同关注的人，你可以使用`SINTER`命令来获取两个用户的关注 Set 的交集。

   示例：`SINTER userA:following userB:following`

3. 检查是否关注：如果你想要检查用户 A 是否关注了用户 B，你可以使用`SISMEMBER`命令来检查用户 B 是否在用户 A 的关注 Set 中。

   示例：`SISMEMBER userA:following "userB"`

4. 可能认识的人：如果你想要推荐用户 A 可能认识的人，你可以使用`SDIFF`命令来获取用户 B 的关注 Set 和用户 A 的关注 Set 的差集，也就是用户 B 关注的人中用户 A 没有关注的人。

   示例：`SDIFF userB:following userA:following`

### Sorted Set

和集合一样也是字符串的集合,且不允许重复的成员。所有成员都会被分配一个浮点数作为分数。根据分数对集合进行从小到大的排序。集合中的成员是唯一的,但分数(score)却可以重复。

1. 排行榜：在游戏或者社交网络应用中，你可以使用 Sorted Set 来存储用户的分数或者排名。例如，当用户获取了新的分数时，你可以使用`ZADD`命令将用户的分数添加到 Sorted Set 中。

   示例：`ZADD game:1:scores 100 "user1"`

   然后，你可以使用`ZRANK`命令来获取用户在排行榜中的排名，或者使用`ZREVRANK`命令来获取用户在排行榜中的倒序排名。

   示例：`ZRANK game:1:scores "user1"` 或者 `ZREVRANK game:1:scores "user1"`

2. 时间线或者日程表：如果你的应用有时间线或者日程表的功能，你可以使用 Sorted Set 来存储事件。你可以使用事件的时间戳作为分数，然后使用`ZADD`命令将事件添加到 Sorted Set 中。

   示例：`ZADD timeline 1622275200 "event1"`

   然后，你可以使用`ZRANGE`命令来获取一段时间内的事件。

   示例：`ZRANGE timeline 1622275200 1622361600`

以上就是一些 Sorted Set 数据类型在 Redis 中的应用场景和具体命令示例，希望对你有所帮助。

3. 如果你有两个游戏，每个游戏都有一个分数排行榜，你可以使用ZUNIONSTORE命令来计算两个游戏的总分数排行榜。
   
    示例：`ZUNIONSTORE total_scores 2 game1:scores game2:scores`
    这个命令将计算game1:scores和game2:scores的并集，并将结果存储在total_scores中。  

4. 如果你有两个社交网络群组，每个群组都有一个活跃用户排行榜，你可以使用ZINTERSTORE命令来计算两个群组的活跃用户交集。
    示例：`ZINTERSTORE active_users 2 group1:active_users group2:active_users`
    这个命令将计算group1:active_users和group2:active_users的交集，并将结果存储在active_users中。